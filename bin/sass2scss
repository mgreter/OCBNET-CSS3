#!/usr/bin/perl
####################################################################################################
# sass to scss syntax converter
####################################################################################################

use strict;
use warnings;

####################################################################################################
# dependencies
####################################################################################################

# parse options
use Pod::Usage;
use Getopt::Long;

####################################################################################################
# config variables
####################################################################################################

# init options
my $pretty = 0;

# define a sub to print out the version (mimic behaviour of node.js blessc)
# this script has it's own version numbering as it's not dependent on any libs
sub version { print "sass2scss 0.2.0 (SASS to SCSS Converter) [Perl]"; exit 0; };

# get options
GetOptions (
	'help|h' => sub { pod2usage(1); },
	'version|v' => \ &version,
	'pretty+' => \ $pretty,
);

####################################################################################################
# status variables
####################################################################################################

# whitespace buffer
my $ws = '';

# concat next line
my $comma = 0;

# is in comment node
my $comment = 0;

# indentation tree
my @indent = ('');

####################################################################################################
# helper
####################################################################################################

# flush whitespace and
# print additional text
# but only print additional
# chars and buffer whitespace
# ***************************************************************************************
sub flush
{

	# flush whitespace now
	print $ws; $ws = '';

	# process each line
	foreach my $line (@_)
	{
		# remove newlines
		my $rv = chomp $line;
		# buffer newlines
		$ws .= "\n" x $rv;
		# print text
		print $line;
	}
	# EO each line

}
# EO sub flush

####################################################################################################
# pretty print routines
####################################################################################################

# functions to deliver scope delimiters
# ***************************************************************************************
sub closer { $pretty ? "\n" . $indent[-1] . "}" : " }" }
sub opener { $pretty > 1 ? "\n" . $indent[-1] . "{" : " {" }

####################################################################################################
# get input resource
####################################################################################################

# filehandle
my $fh;

# some minimalistic error handling
die "sass2scss: no input file\n" unless $ARGV[0];

# open filehandle
if ($ARGV[0] ne '-')
{

	# open the passed filename
	my $rv = open($fh, '<', $ARGV[0]);
	# give an error message if file reading failed
	die "sass2scss: error reading input file\nerror: $!" unless $rv;

}
# or use standard input
else { $fh =  \*STDIN; }

####################################################################################################
# main subroutine
####################################################################################################

# process a line
sub process ($)
{

	# get input
	my ($line) = @_;

	# has only whitespace
	if ($line =~ m/\A\s*\z/s)
	{
		# add whitespace
		$ws .= $line;
	}

	# any line must now match this
	# capture indent level of this line
	elsif ($line =~ m/\A(\s*)/s)
	{

		# store indent string
		my $indent = $1;

		# was one-line comment
		if ($comment eq '/')
		{
			# close comment
			print " */";
			# unset flag
			$comment = 0;
		}
		# special case for multiline comment, when the next
		# line is on the same indentation as the actual comment
		# I assume that this means we should close the comment node
		elsif ($comment eq "*" && length($indent) == length($indent[-1]))
		{
			# close comment
			print " */";
			# unset flag
			$comment = 0;
		}
		# current line has less or same indentation
		elsif (length($indent) <= length($indent[-1]))
		{
			# add semicolon if not in concat mode
			print ";" unless $comment || $comma;
		}

		# make sure we close every "higher" block
		while (length($indent) < length($indent[-1]))
		{
			# close block
			pop(@indent);
			# print closer
			if ($comment)
			{ print " */"; }
			else { print closer; }
			# reset comment
			$comment = 0;
		}

		# current line has more indentation
		if (length($indent) > length($indent[-1]))
		{
			# print block opener
			print opener unless $comment;
			# open new block if not in comment
			push(@indent, $indent) unless $comment;
			# open new block if comment is opening
			# be smart and only require the same indentation
			# level as the comment node itself, plus one char
			push(@indent, $indent[-1] . ' ') if $comment eq "*";
			# set comment to current indent
			# multiline comments must be indented
			# indicates multiline if not eq "*"
			$comment = $indent if $comment;
		}

		# check if current line starts a comment
		if ($line =~ s/\A(\s*)\/([\/\*])/$1\/\*/s)
		{
			# close previous comment
			print " */" if $comment;
			# remove indentation from previous comment
			pop @indent if $comment && $comment ne "*";
			# set comment flag
			$comment = $2;
		}

		# flush line
		flush($line);

		# check if next line should be concatenated
		$comma = $line =~ m/,\s*\z/s unless $comment;

		# check if multiline comment is closed
		$comment = '' if ($line =~ m/\*\/\s*\z/);

	}
	# EO has indent

}

####################################################################################################
# main process
####################################################################################################

# process each line of handle
# ***************************************************************************************
process $_ while <$fh>;

# make sure to finish
# ***************************************************************************************
process ";";

####################################################################################################
####################################################################################################

__END__

=head1 NAME

sass2scss - SASS to SCSS Converter

=head1 SYNOPSIS

sass2scss [options] [ source | - ]

 Options:
   -v, --version      print version
   -h, --help         print this help
   -p, --pretty       pretty print output

=head1 OPTIONS

=over 8

=item B<-help>

Print a brief help message with options and exits.

=back

=head1 DESCRIPTION

B<This program> is a SASS to SCSS Converter

=cut